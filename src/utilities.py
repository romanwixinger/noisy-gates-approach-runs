""" Utilities for the runs.

Note:
    As migrated from
    https://github.com/CERN-IT-INNOVATION/quantum-gates/blob/main/src/quantum_gates/_utility/simulations_utility.py.

Todo:
    Fix unpacking of device parameters.
"""

import numpy as np

from qiskit import transpile
from qiskit.transpiler import CouplingMap
from qiskit.providers.aer import AerSimulator
from qiskit.providers.aer.noise import NoiseModel
from qiskit.providers.aer.noise import pauli_error
from qiskit.providers.aer.noise import depolarizing_error
from qiskit.providers.aer.noise import phase_amplitude_damping_error


def create_qc_list(circuit_generator, nqubits_list, qubits_layout, backend):
    """ Creates a list of quantum circuit.

    Args:
        circuit_generator (callable): Function which takes the number of qubits and returns a Qiskit circuit.
        nqubits_list (list[int]): List of the qubit numbers for which a quantum circuit should be generated.
        qubits_layout (list[int]): Layout of the qubits in the backend.
        backend: IBM backend.

    Returns:
        A list of transpiled circuits, generated by the Qiskit transpiler. The list items correspond 1:1 to the items in
        the list of qubits.
    """
    print("Warning:")
    print("1) At the moment, we perform the transpilation step in two steps because of a bug in Qiskit. ")
    print("   See https://qiskit.slack.com/archives/C7SS31917/p1670411292978089 for more infos.")
    print("2) We assume a linear connectivity.")
    sim = AerSimulator()
    result_list = []
    for nqubit in nqubits_list:
        coupling_map = CouplingMap.from_line(nqubit, bidirectional=True)
        qc1 = transpile(
            circuits=circuit_generator(nqubit),
            backend=sim,
            coupling_map=coupling_map,
            seed_transpiler=42
        )
        qc2 = transpile(
            circuits=qc1,
            backend=backend,
            scheduling_method='asap',
            initial_layout=qubits_layout[0:nqubit],
            seed_transpiler=42,
        )
        result_list.append(qc2)
    return result_list


def construct_ibm_noise_model(backend, qubits_layout, device_param):
    """ IBM noise model for Qiskit with depolarization, relaxation and spam.
    """

    tg = 35 * 10**(-9)

    nqubit = len(qubits_layout)
    noise_model = NoiseModel()

    # Todo: Fix, in the new version the number of entries is different.
    T1, T2, p, rout, p_cnot, t_cnot = device_param.get_as_tuple()

    for j in range(0,nqubit):

        # Single qubit depolarizing
        dep = depolarizing_error(p[j],1)

        # Single qubit relaxation
        Tph = T1[j] * T2[j] / (2 * T1[j] - T2[j])
        p1 = 1 - np.exp(-tg/T1[j])
        p_ph = 1 - np.exp(-tg/Tph)
        pz = (1 - p1) * p_ph

        relax = phase_amplitude_damping_error(p1,pz)

        # Spam
        spam = pauli_error([('X',rout[j]), ('I', 1 - rout[j])])

        # Adding errors to noise model
        single_qubit_gate_error = dep.compose(relax)
        noise_model.add_quantum_error(single_qubit_gate_error, ["x","sx"],[qubits_layout[j]])
        noise_model.add_quantum_error(spam, "measure",[qubits_layout[j]])

    for j in range(0, nqubit):
        for k in range(0,nqubit):
            if (k == j+1 or k == j-1):

                # Two qubits relaxation
                Tph_j = T1[j] * T2[j] / (2 * T1[j] - T2[j])
                p1_j = 1 - np.exp(-t_cnot[j][k]/T1[j])
                p_ph_j = 1 - np.exp(-t_cnot[j][k]/Tph_j)
                pz_j = (1 - p1_j) * p_ph_j

                Tph_k = T1[k] * T2[k] / (2 * T1[k] - T2[k])
                p1_k = 1 - np.exp(-t_cnot[j][k]/T1[k])
                p_ph_k = 1 - np.exp(-t_cnot[j][k]/Tph_k)
                pz_k = (1 - p1_k) * p_ph_k

                relax_j = phase_amplitude_damping_error(p1_j,pz_j)
                relax_k = phase_amplitude_damping_error(p1_k,pz_k)
                relax_jk = relax_k.tensor(relax_j)

                # Two qubits depolarizing
                dep_j = depolarizing_error(p_cnot[j][k],1)
                dep_k = depolarizing_error(p_cnot[j][k],1)
                dep_cnot = dep_k.tensor(dep_j)

                # Adding errors to noise model
                two_qubits_gate_error = dep_cnot.compose(relax_jk)
                noise_model.add_quantum_error(two_qubits_gate_error, "cx",[qubits_layout[j],qubits_layout[k]])

    return noise_model
